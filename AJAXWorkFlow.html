<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AJAX / Callback Hell / async-await</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
</head>

<body>
    <div class="container py-3">
        <header class="mb-3">
            <h1 class="mb-2">비동기 흐름 실습</h1>
            <p class="mb-0">
                이 페이지는 <b>AJAX 비동기 실행</b> → <b>콜백지옥</b> → <b>async/await</b> 순서로 문제와 해결을 체감하는 실습이다.
                개발자도구(Console)를 열고 탭을 클릭할 때 출력 순서를 확인해보자.
            </p>
        </header>

        <section class="mb-3">
            <h2 class="h5">핵심 개념(짧게)</h2>
            <ul class="mb-0">
                <li><b>비동기</b>: 요청을 시작만 해두고, 완료를 기다리지 않고 다음 코드로 진행한다.</li>
                <li><b>콜백</b>: “완료되면 실행할 코드”를 함수로 넘겨두는 패턴이다.</li>
                <li><b>문제</b>: 응답이 필요한 다음 작업이 계속 생기면 콜백이 중첩되어 가독성이 떨어진다.</li>
                <li><b>해결</b>: async/await로 “순차 코드처럼 읽히는 구조”로 바꾼다.</li>
            </ul>
        </section>

        <!-- Tabs -->
        <ul class="nav nav-tabs" id="demoTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="ajax-tab" data-bs-toggle="tab" data-bs-target="#ajax-pane"
                    type="button" role="tab" aria-controls="ajax-pane" aria-selected="true">
                    AJAX
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="hell-tab" data-bs-toggle="tab" data-bs-target="#hell-pane" type="button"
                    role="tab" aria-controls="hell-pane" aria-selected="false">
                    콜백지옥
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="async-tab" data-bs-toggle="tab" data-bs-target="#async-pane" type="button"
                    role="tab" aria-controls="async-pane" aria-selected="false">
                    async-await
                </button>
            </li>
        </ul>

        <!-- Tab contents -->
        <div class="tab-content border border-top-0 p-3" id="demoTabsContent">
            <!-- AJAX -->
            <div class="tab-pane fade show active" id="ajax-pane" role="tabpanel" aria-labelledby="ajax-tab"
                tabindex="0">
                <h2 class="h4 mb-2">AJAX (비동기 실행 확인)</h2>
                <p class="mb-2">
                    Ajax 요청(jQuery, Axios 등)은 비동기적으로 실행되기 때문에, 요청을 시작한 직후에도 다음 줄 코드가 먼저 실행될 수 있다.
                </p>

                <h3 class="h6 mt-3">관찰 포인트</h3>
                <ul class="mb-3">
                    <li>콘솔에서 <code>실행순서 1</code>이 먼저 찍히는지 확인</li>
                    <li>응답이 도착한 뒤 <code>실행순서 2 → (result 출력) → 실행순서 3</code>이 한 묶음으로 실행되는지 확인</li>
                </ul>

                <details class="mb-3">
                    <summary class="fw-semibold">왜 이런 순서가 나오나?</summary>
                    <div class="mt-2">
                        <p class="mb-2">
                            네트워크 요청은 시간이 걸릴 수 있다. 그래서 요청을 “보내기”만 하고,
                            응답이 오면 그때 등록해 둔 <b>success 콜백</b>이 실행된다.
                        </p>
                        <p class="mb-0">
                            따라서 “요청 다음 줄”은 응답을 기다리지 않고 먼저 실행될 수 있다.
                        </p>
                    </div>
                </details>

                <pre class="bg-light p-3 border rounded overflow-auto mb-0"><code>// 기대 관찰(예시)
// 실행순서 1
// 실행순서 2
// { ...result... }
// 실행순서 3</code></pre>
            </div>

            <!-- Callback Hell -->
            <div class="tab-pane fade" id="hell-pane" role="tabpanel" aria-labelledby="hell-tab" tabindex="0">
                <h2 class="h4 mb-2">콜백지옥 (중첩 문제)</h2>
                <p class="mb-2">
                    “첫 번째 요청의 응답을 이용해서 두 번째 요청을 보내야 한다”처럼
                    <b>순서 의존</b>이 생기면, 비동기 요청의 다음 단계는 보통 이전 단계의 success 안에 들어가게 된다.
                </p>

                <h3 class="h6 mt-3">관찰 포인트</h3>
                <ul class="mb-3">
                    <li>콘솔에서 <code>A</code>가 먼저 찍히는지 확인</li>
                    <li>이후 네트워크 응답 흐름에 따라 <code>B → C → D</code>가 순서대로 찍히는지 확인</li>
                    <li>코드가 success 안으로 계속 깊어지며 가독성이 떨어지는지 확인</li>
                </ul>

                <div class="alert alert-warning">
                    <div class="fw-semibold mb-1">콜백지옥이 불편한 이유</div>
                    <ul class="mb-0">
                        <li>코드 들여쓰기가 깊어져 읽기 어렵다.</li>
                        <li>에러 처리(error)가 단계마다 반복되어 중복이 늘어난다.</li>
                        <li>중간 단계 추가/삭제가 힘들어 유지보수가 어려워진다.</li>
                    </ul>
                </div>

                <img style="max-width: 500px; width: 100%;" src="./images//callback_hell.png" alt="콜백지옥 예시"
                    class="border rounded">

                <pre class="bg-light p-3 border rounded overflow-auto mt-3 mb-0"><code>// 기대 관찰(예시)
// A
// B
// C
// D
// { ...result... }</code></pre>
            </div>

            <!-- async-await -->
            <div class="tab-pane fade" id="async-pane" role="tabpanel" aria-labelledby="async-tab" tabindex="0">
                <h2 class="h4 mb-2">async-await (가독성 개선)</h2>
                <p class="mb-2">
                    async/await는 비동기 코드를 “순차 코드처럼 읽히게” 만들어,
                    콜백 중첩을 줄이고 에러 처리도 한 곳으로 모을 수 있게 해준다.
                </p>

                <h3 class="h6 mt-3">관찰 포인트</h3>
                <ul class="mb-3">
                    <li><code>A</code>는 비동기 함수 호출 직후 먼저 찍힐 수 있음</li>
                    <li><code>await</code> 때문에 요청 결과 출력은 <code>B → C → D</code> 순서대로 보장됨</li>
                    <li>에러는 <code>try/catch</code>로 한 번에 처리 가능</li>
                </ul>

                <details class="mb-3">
                    <summary class="fw-semibold">왜 A가 먼저 찍힐까?</summary>
                    <div class="mt-2">
                        <p class="mb-0">
                            async 함수는 호출하면 “바로 리턴”하고, 내부 로직은 await 지점에서
                            응답을 기다렸다가 다음 줄로 진행한다. 그래서 바깥쪽 로그(A)가 먼저 찍힐 수 있다.
                        </p>
                    </div>
                </details>

                <pre class="bg-light p-3 border rounded overflow-auto mb-0"><code>// 기대 관찰(예시)
// A
// B
// { ...result1... }
// C
// { ...result2... }
// D
// { ...result3... }</code></pre>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.0.js"></script>

    <!-- Scripts (원래 코드 흐름 유지) -->
    <script>
        // 1) AJAX 예제
        const ajaxDemo = () => {
            $(document).ready(() => {
                $.ajax({
                    url: "https://jsonplaceholder.typicode.com/posts/1",
                    type: "GET",
                    dataType: "json",
                    success: (result) => {
                        console.log("실행순서 2");
                        console.log(result);
                        console.log("실행순서 3");
                    },
                    error: (error) => { }
                });
            });

            console.log("실행순서 1");
        };

        // 2) 콜백지옥 예제
        const callbackHellDemo = () => {
            $(document).ready(() => {
                $.ajax({
                    url: "https://jsonplaceholder.typicode.com/posts/1",
                    type: "GET",
                    dataType: "json",
                    success: (result) => {
                        console.log("B");
                        $.ajax({
                            url: "https://jsonplaceholder.typicode.com/posts/1",
                            type: "GET",
                            dataType: "json",
                            success: (result) => {
                                console.log("C");
                                $.ajax({
                                    url: "https://jsonplaceholder.typicode.com/posts/1",
                                    type: "GET",
                                    dataType: "json",
                                    success: (result) => {
                                        console.log("D");
                                        console.log(result);
                                    },
                                    error: (error) => { }
                                });
                            },
                            error: (error) => { }
                        });
                    },
                    error: (error) => { }
                });
            });

            console.log("A");
        };

        // 3) async-await 예제
        const requestPost = () => {
            return $.ajax({
                url: "https://jsonplaceholder.typicode.com/posts/1",
                type: "GET",
                dataType: "json",
            });
        };

        const asyncAwaitDemo = async () => {
            try {
                const result1 = await requestPost();
                console.log("B");
                console.log(result1);

                const result2 = await requestPost();
                console.log("C");
                console.log(result2);

                const result3 = await requestPost();
                console.log("D");
                console.log(result3);
            } catch (e) {
                console.log("error", e);
            }
        };

        const runAsyncAwaitDemo = () => {
            $(document).ready(() => {
                asyncAwaitDemo();
                console.log("A");
            });
        };

        // 탭이 "처음 보여질 때"마다 자동 실행(중복 실행 방지 플래그)
        let ranAjax = false;
        let ranHell = false;
        let ranAsync = false;

        const runByTabId = (tabId) => {
            if (tabId === "ajax-tab" && !ranAjax) {
                ranAjax = true;
                ajaxDemo();
            }
            if (tabId === "hell-tab" && !ranHell) {
                ranHell = true;
                callbackHellDemo();
            }
            if (tabId === "async-tab" && !ranAsync) {
                ranAsync = true;
                runAsyncAwaitDemo();
            }
        };

        // 첫 탭은 로드시 실행
        runByTabId("ajax-tab");

        // 탭 전환 시 실행
        document.querySelectorAll('button[data-bs-toggle="tab"]').forEach((btn) => {
            btn.addEventListener("shown.bs.tab", (e) => {
                runByTabId(e.target.id);
            });
        });
    </script>
</body>

</html>